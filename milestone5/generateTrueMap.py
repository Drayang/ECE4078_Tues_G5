# evaluate the map generated by SLAM against the true map using our own transform x and theta and generate Truemap
import ast
import numpy as np
import json
import matplotlib.pyplot as plt
import re

# ------------ changes -----------------#
### read the robot pose from the slam state also
def parse_user_map(fname : str) -> dict:
    with open(fname, 'r') as f:
        usr_dict = ast.literal_eval(f.read())
        aruco_dict = {}
        final_robot_pose = []
        for (i, tag) in enumerate(usr_dict["taglist"]):
            aruco_dict[tag] = np.reshape([usr_dict["map"][0][i],usr_dict["map"][1][i]], (2,1))
    
        for (i, tag) in enumerate(usr_dict["final_robot_pose"]):
            final_robot_pose.append(tag[0])
    
    return aruco_dict,np.hstack(final_robot_pose)


### convert user aruco dict enough, no need true map
def match_aruco_points(aruco0 : dict):
    # aruco0 - user de aruco dict, aruco1 - truemap de

    points0 = []
    points1 = []
    keys = []
    for key in aruco0:
        # if not key in aruco1:
        #     continue
        
        points0.append(aruco0[key]) # read aruco0 dictionary - e.g key = 'aruco1_0'
        # points1.append(aruco1[key])
        keys.append(key)
    return keys, np.hstack(points0)

# convert target.txt to vector so we can apply_transform()
def match_fruit_points():
    fruitfile = "lab_output/targets.txt"
    with open(fruitfile,'r') as f:
        try:
            fruit_dict = json.load(f)                   
        except ValueError as e:
            with open(fname, 'r') as f:
                fruit_dict = ast.literal_eval(f.readline())  

    print("fruit_dict:", fruit_dict)

    pointsx = []
    pointsy = []
    fruit_vec =[]
    fruitkeys = []
    for key in fruit_dict:        
        pointsx.append(fruit_dict[key]['x']) # read aruco0 dictionary - e.g key = 'aruco1_0'
        pointsy.append(fruit_dict[key]['y'])
        fruitkeys.append(key)
    # points0 = np.hstack(points0)
    fruit_vec =[pointsx,pointsy]
    print("fruit_vec",fruit_vec)

    return fruitkeys,np.array(fruit_vec)

### similar to solve_umeqyam2d method, to find theta and x
def find_transform(points1,points2):
    # points1 - robot real pose, points2 - robot pose from slamstate
    
    theta = points1[2] - points2[2]
    # theta = 1
    c, s = np.cos(theta), np.sin(theta)
    R = np.array(((c, -s), (s, c)))
    x = np.array([[points1[0] ],[points1[1]]]) - R @ np.array([[points2[0]],[points2[1]]])
    
    return theta, x

# ------------ changes -----------------#

def apply_transform(theta, x, points):
    # Apply an SE(2) transform to a set of 2D points
    assert(points.shape[0] == 2)
    
    c, s = np.cos(theta), np.sin(theta)
    R = np.array(((c, -s), (s, c)))

    points_transformed =  R @ points + x
    return points_transformed

# points1- us_vec_alligned, points2- truemap point
def compute_rmse(points1, points2):
    # Compute the RMSE between two matched sets of 2D points.
    assert(points1.shape[0] == 2)
    assert(points1.shape[0] == points2.shape[0])
    assert(points1.shape[1] == points2.shape[1])
    num_points = points1.shape[1]
    residual = (points1-points2).ravel()
    MSE = 1.0/num_points * np.sum(residual**2)

    return np.sqrt(MSE)


if __name__ == '__main__':
    import argparse

    estimate = "lab_output/slam.txt"
    us_aruco,final_robot_pose = parse_user_map(estimate)

    taglist, us_vec = match_aruco_points(us_aruco)
    print("Taglist :",taglist)
    print("us_vec :",us_vec)
    print("us_vec shape: ",us_vec.shape) # ( 2,10) -(x,y)
    idx = np.argsort(taglist)
    taglist = np.array(taglist)[idx] # sorted de tag - [1 2 3 4 5.... 10]
    print("taglist:",taglist)
    us_vec = us_vec[:,idx]

    fruitkeys, fruit_vec = match_fruit_points()

    # final_robot_pose - final robot pose based on the SLAM
    # real_robot_pose - the actual robot pose in arena [x,y,theta]
    #--------------- INPUT ARGUMENT --------------#
    while True:
        x,y,rad = 0.0,0.0,0.0
        x = input("X coordinate of the robot at final position: ")
        try:
            x = float(x)
        except ValueError:
            print("Please enter a number.")
            continue
        y = input("Y coordinate of the robot at final position: ")
        try:
            y = float(y)
        except ValueError:
            print("Please enter a number.")
            continue
        rad = input("Angle (rad) of the robot at final position: ")
        try:
            rad = float(rad)
        except ValueError:
            print("Please enter a number.")
            continue
        break

    real_robot_pose = np.hstack([x, y,rad])
    theta, x = find_transform(real_robot_pose,final_robot_pose)
    print("us_vec")
    us_vec_aligned = apply_transform(theta, x, us_vec)

    # for fruit TODO: (NO NEED RUN THIS if i working seperately) ----------------------------------------------
    # fruit_vec_aligned = apply_transform(theta, x, fruit_vec)
    fruit_vec_aligned = fruit_vec


    print()
    print("The following parameters optimally transform the estimated points to the ground truth.")
    print("Rotation Angle: {}".format(theta))
    print("Translation Vector: ({}, {})".format(x[0,0], x[1,0]))
    
  
    ax = plt.gca()
    ax.scatter(us_vec_aligned[0,:], us_vec_aligned[1,:], marker='x', color='C1', s=100)

    #--------- FOr fruit ----------#
    ax.scatter(fruit_vec_aligned[0,:], fruit_vec_aligned[1,:], marker='o', color='C2', s=100)


    for i in range(len(taglist)):
        if (taglist[i]>10):
            continue
        ax.text(us_vec_aligned[0,i]+0.05, us_vec_aligned[1,i]+0.05, taglist[i], color='C1', size=12)
    for i in range(len(fruitkeys)):
        ax.text(fruit_vec_aligned[0,i]+0.05, fruit_vec_aligned[1,i]+0.05, fruitkeys[i], color='C2', size=12)
    plt.title('Arena')
    plt.xlabel('X')
    plt.ylabel('Y')
    ax.set_xticks([-1.6, -1.2, -0.8, -0.4, 0, 0.4, 0.8, 1.2, 1.6])
    ax.set_yticks([-1.6, -1.2, -0.8, -0.4, 0, 0.4, 0.8, 1.2, 1.6])
    plt.legend(['Aruco','Fruit'])
    plt.grid()
    plt.show()



    # Generate TRUEMAP.txt
    map_dict = {}
    for (i, tag) in enumerate(taglist):
        if (tag>10):
            continue
        coord = {"x":us_vec_aligned[0][i],"y":us_vec_aligned[1][i]}
        map_dict["aruco"+str(tag)+"_0"] = coord
    for (i, tag) in enumerate(fruitkeys):
        coord = {"x":fruit_vec_aligned[0][i],"y":fruit_vec_aligned[1][i]}
        map_dict[str(tag)] = coord

    print("map_dict:",map_dict)
    with open("TRUEMAP_m5.txt", 'w') as map_f:
        json.dump(map_dict, map_f, indent=2)
